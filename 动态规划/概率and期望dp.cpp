//给定一个n面的骰子，问投出n个不同的面的期望投掷次数。 （1<=n<=1000）
//dp[i]表示已经投出了i个面，要投出剩余n-i面的期望次数
//对于当前状态为i，投一次骰子，有i/n的可能投中已经出现的i个面之一，此情况下还需要投dp[i]次
//有(n-i)/n的可能投出其余n-i面。此情况下还要投dp[i+1]次
//即：由于投出的面可能出现过，也可能没出现过，所以dp[i]由dp[i] 与 dp[i+1] 转移而来
//dp[i]=dp[i]*(i/n) + dp[i+1]*((n-i)/n) +1   （+1是因为要投一次骰子才能转移）
//移项变成：dp[i]=dp[i+1] + n/(n-i)
void solve(){
    int n;cin>>n;
    vector<double> dp(n+1);//dp[n]=0,末状态以确定，逆推
    for(int i=n-1;i>=0;i--) dp[i]=dp[i+1]+1.0*n/(n-i);
    cout<<fixed<<setprecision(2)<<dp[0]<<'\n';
}