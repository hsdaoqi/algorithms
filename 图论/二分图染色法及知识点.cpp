1.最小点覆盖
	定义：给定一张二分图，求出一个最小的点集S，使得图中任意一条边都有至少一个端点属于S。
	Konig定理：二分图最小点覆盖包含的点数等于二分图最大匹配包含的边数。
	证明：若一个二分图的最小点覆盖不等于该二分图的最大匹配，则存在一条边未被覆盖，该二分图存在更大的匹配，不存在，证毕
2. 最大独立集
	最大独立集：选取尽可能多的点使得点集中所有点两两之间无边相连。
	最大团：选取尽可能多的点使得点集中所有点两两之间都有边相连，与最大独立集互补。
	定理：最大独立集 = n – 最大匹配数（n为图的节点个数）
	证明：我们要选择尽可能多的点使得两两之间无边相连，反向考虑就是找最少的点使得拆散所有的边，那么我们只要找到最小点覆盖，然后把最小点覆盖里	的点全都去掉，那么图中就不存在边了，那么剩下的就是最大独立集，由于最小点覆盖数=最大匹配数，故最大独立集 = n – 最大匹配数
3. 最小路径点覆盖
	定义：在一个有向无环图中（DAG）用最少的不相交的简单路径覆盖所有的点
	定理：拆点构造二分图：将DAG中每个点x拆成x和x+n两个点，分别作为一张新二分图的左部和右部，则 编号为1 – n的点为二分图左部，n+1 – 2n的点为	右部，对于原图每条有向边(x，y),在二分图的左部点x与右部点y+n之间连边，得到拆点二分图，记为G，则最小路径覆 盖=原图点个数-G的最大匹配数
	证明： 一开始每个点都是独立的为一条路径，总共有n条不相交路径。我们每次在二分图里找一条匹配边就相当于把两条路径合成了一条路径，也就相当于	路径数减少了1。所以找到了几条匹配边，路径数就减少了多少。所以有最小路径覆盖=原图的结点数-新图的最大匹配数
4.DAG的最小可相交路径覆盖
	定义： 在一个有向图中，找出最少的可相交路径，使得这些路径经过了所有的点。
	用Floyd判断任意两点之间的连通性，若X与Y相连通，连接X,Y。然后将其转化为DAG的最小不相交路径覆盖
	证明： 为了连通两个点，某条路径可能经过其它路径的中间点。比如1->3->4，2->4->5。但是如果两个点a和b是连通的，只不过中间需要经过其它的	点，那么可以在这两个点之间加边，那么a就可以直达b，不必经过中点的，那么就转化成了最小不相交路径覆盖
5.一些转化
	最大团 = 补图的最大独立集


bool stain(vector<vector<int>> &adj){
    vector<int> col(adj.size(),-1);
    function<bool(int,int)> dfs=[&](int u,int c)->bool{
        col[u]=c;
        for(int v:adj[u]){
            if(col[v]==-1){
                if(!dfs(v,c^1)) return false;
            }else if(col[v]==c) return false;
        }
        return true;
    };
    for(int i=1;i<col.size();i++){
        if(col[i]==-1){
            if(!dfs(i,1)) return false;
        }
    }
    return true;
}

