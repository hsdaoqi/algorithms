1. 欧拉路径定义：
图中经过所有边恰好一次的路径叫欧拉路径（也就是一笔画）。如果此路径的起点和终点相同，则称其为一条欧拉回路。
2. 欧拉路径判定（是否存在）：
有向图欧拉路径：图中恰好存在 1 个点出度比入度多 1（这个点即为 起点 S），1个点入度比出度多 1（这个点即为 终点 T），其余节点出度=入度。
有向图欧拉回路：所有点的入度=出度（起点 S 和终点 T 可以为任意点）。
无向图欧拉路径：图中恰好存在 2 个点的度数是奇数，其余节点的度数为偶数，这两个度数为奇数的点即为欧拉路径的 起点 S 和 终点 T。
无向图欧拉回路：所有点的度数都是偶数（起点 S 和终点 T 可以为任意点）

3. 寻找欧拉路径（默认存在）：

首先根据题意以及判定先确定起点 S。从起点 S 开始 dfs 。
dfs 伪代码如下：
void dfs(int now)
{
	枚举now的出边。
		如果该边还未被访问
			标记为已访问
			dfs(该边连向的另一个点)
	now入栈
}
最后倒序输出栈内的所有节点即可
//cur[u]之前的边已经被访问过，下次直接从cur[u]开始访问
function<void(int)> dfs=[&](int u){//第一种
        for(int i=cur[u];i<adj[u].size();i=cur[u]){
            cur[u]=i+1;
            dfs(adj[u][i]);
        }
        st.push(u);
    };

function<void(int)> dfs=[&](int u){//第二种
        for(int i=1;i<=n;i++){
            if(adj[u][i]){
                adj[u][i]--;
                adj[i][u]--;
                dfs(i);
            }
        }
        st.push(u);
    };

    dfs(s);
    while(!st.empty()){
        cout<<st.top()<<" ";
        st.pop();
    }